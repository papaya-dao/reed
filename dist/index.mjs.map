{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ParsedTransactionResult, Simnet } from \"@hirosystems/clarinet-sdk\";\nimport { Cl, ClarityValue } from \"@stacks/transactions\";\nimport { createAddress } from \"@stacks/transactions\";\n\nexport const TESTNET_ZERO_ADDRESS = 'ST000000000000000000002AMW42H';\n\ntype Bigintish = bigint | number | string;\nfunction isBigintish(value: any): value is Bigintish {\n    return typeof value === 'bigint' || typeof value === 'number' || typeof value === 'string';\n}\n\nexport interface ExtendedParsedTransactionResult extends ParsedTransactionResult {}\n\nexport class ExtendedParsedTransactionResult implements ParsedTransactionResult {\n  result: ClarityValue;\n  events: { event: string; data: { [key: string]: any; raw_value?: string | undefined; value?: ClarityValue | undefined; }; }[];\n  _expect: Function;\n  constructor(txn: ParsedTransactionResult, expect: Function) {\n    this.result = txn.result;\n    this.events = txn.events\n    this._expect = expect;\n  }\n\n  get expect() {\n    return this._expect(this.result);\n  }\n}\n\n/**\n * The ExtendedSimnet class is an extension of the Simnet class from the \"@hirosystems/clarinet-sdk\" package.\n * It provides additional methods and properties for interacting with the Simnet network.\n * \n * This class uses the Proxy pattern to override the methods of the Simnet class, providing more flexibility.\n * For example, the 'connect' method allows you to connect to the Simnet network with a specified sender.\n * The 'callReadOnlyFn' and 'callPublicFn' methods are overridden to use the sender specified in the 'connect' method by default.\n * \n * @property {Simnet} simnet - The Simnet instance.\n * @property {string} sender - The sender's address.\n * \n * @method constructor - The constructor method. It is private to prevent direct instantiation.\n * @method create - A static method that creates a new instance of the ExtendedSimnet class. It uses a Proxy to override the methods of the Simnet class.\n * @method connect - Connects to the Simnet network with a specified sender. If the sender is not specified, it throws an error.\n * @method callReadOnlyFn - Calls a read-only function on the Simnet network. If the sender is not specified, it uses the sender specified in the 'connect' method.\n * @method callPublicFn - Calls a public function on the Simnet network. If the sender is not specified, it uses the sender specified in the 'connect' method.\n * @method getPrincipal - Returns the sender's address.\n */\n\nexport interface ExtendedSimnet extends Simnet {\n  // Add any additional methods or properties here\n  connect(sender: string | undefined): ExtendedSimnet;\n}\n\nexport interface ExtendedSimnetParams {\n  simnet: Simnet;\n  sender?: string;\n  debug?: boolean;\n  expect?: Function\n}\n\n\nexport class ExtendedSimnet implements Simnet {\n    private simnet: Simnet;\n    sender: string;\n    _debug: boolean;\n    _defaultSender = 'wallet_1';\n    private _expect: Function;\n    private _expectFallback = () => {throw new Error(\"Expect chaining disabled: `expect` function was not passed as parameter\")};\n\n    private constructor(params: ExtendedSimnetParams) {\n        this.simnet = params.simnet;\n        this.sender = this._parseSender(params.sender || 'wallet_1');\n        this._debug = !!params.debug;\n        this._expect = params.expect || this._expectFallback;\n    }\n    private getParams(): ExtendedSimnetParams {\n      return {\n        simnet: this.simnet,\n        sender: this.sender,\n        debug: this._debug,\n        expect: this._expect,\n      }\n    }\n\n    static create(params: ExtendedSimnetParams) {\n        return new Proxy(new ExtendedSimnet(params), {\n            get: (target, prop: keyof Simnet | keyof ExtendedSimnet, receiver) => {\n                if (prop in ExtendedSimnet.prototype) {\n                  const maybeFn = target[prop as keyof ExtendedSimnet];\n                    if (typeof maybeFn === 'function') {\n                        return function(...args: any[]) {\n                            return (maybeFn as Function).apply(target, args);\n                        };\n                    } else {\n                        return target[prop as keyof ExtendedSimnet];\n                    }\n                } else {\n                    const maybeFn = target.simnet[prop as keyof Simnet];\n                    if (typeof maybeFn === 'function') {\n                        return function(...args: any[]) {\n                            return (maybeFn as Function).apply(target.simnet, args);\n                        };\n                    } else {\n                        return target.simnet[prop as keyof Simnet];\n                    }\n                }\n            }\n        });\n    }\n\n    connect(sender: string | undefined): ExtendedSimnet {\n      const params: ExtendedSimnetParams = {\n        ...this.getParams(),\n        sender: this._parseSender(sender || this._defaultSender)\n      }\n      return ExtendedSimnet.create(params);\n    }\n\n    get debug(): ExtendedSimnet {\n      const params: ExtendedSimnetParams = {\n        ...this.getParams(),\n        debug: true\n      }\n        return ExtendedSimnet.create(params);\n    }\n    \n    callReadOnlyFn(contract: string, method: string, args: ClarityValue[], sender: string = ''): ExtendedParsedTransactionResult {\n        const _sender = sender == '' ? this.sender : sender;\n        const parsedTransactionResult = this.simnet.callReadOnlyFn(contract, method, args, _sender);\n\n        if (this._debug) {\n            console.log(`[DEBUG] ${contract}/${method}:`);\n            console.log(`[DEBUG]     - Sender: ${_sender}`);\n            console.log(`[DEBUG]     - Result: ${Cl.prettyPrint(parsedTransactionResult.result)}`);\n        }\n\n        return new ExtendedParsedTransactionResult(parsedTransactionResult, this._expect);\n    }\n\n    callPublicFn(contract: string, method: string, args: ClarityValue[], sender: string = ''): ExtendedParsedTransactionResult {\n        const _sender = sender == '' ? this.sender : sender;\n        const parsedTransactionResult = this.simnet.callPublicFn(contract, method, args, _sender)\n        \n        if (this._debug) {\n            console.log(`[DEBUG] ${contract}/${method}:`);\n            console.log(`[DEBUG]     - Sender: ${_sender}`);\n            console.log(`[DEBUG]     - Result: ${Cl.prettyPrint(parsedTransactionResult.result)}`);\n            console.log(`[DEBUG]     - Events: [${parsedTransactionResult.events.map(ce => (JSON.stringify({ event: ce.event, data: ce.data.value ? Cl.prettyPrint(ce.data.value) : ce.data.value }, null, 4)))}]`);\n        }\n\n        return new ExtendedParsedTransactionResult(parsedTransactionResult, this._expect);\n    }\n\n    getPrincipal(): string {\n      return this.sender;\n    }\n\n    getDeployedContractPrincipal(contractName: string) {\n      return Cl.contractPrincipal(this.simnet.deployer, contractName);\n    }\n\n    _parseSender(sender: string) {\n      if (!sender) {\n        throw new Error(\"Connected sender is undefined!\");\n      }\n\n      let _sender = '';\n\n      if (isAddress(sender)) {\n        _sender = sender;\n      } else {\n        const maybeAccount = this.simnet.getAccounts().get(sender);\n\n        if (!maybeAccount)\n          throw new Error(`Invalid sender: could not parse as address or get account from ${sender}`);\n\n        _sender = maybeAccount;\n      }\n      return _sender;\n    }\n}\n\nexport const isAddress = (maybeAddress: string) => {\n  let _isAddress = false;\n  try {\n    createAddress(maybeAddress);\n    _isAddress = true;\n  } catch (error) { /* Handle the error silently */}\n\n  return _isAddress;\n}\n\nexport const range = (n: number): number[] => {\n    if (n < 0) throw new Error(\"Negative input is not allowed\");\n    return Array.from({length: n}, (_, i) => i);\n}\n\nconst kebabToCamel = (str: string) => str.split('-').map((s, i) => i > 0 ? `${s[0].toUpperCase()}${s.slice(1)}` : s).join('');\n\nexport class ClarityContract {\n    [x: string]: any;\n    protected simnet: ExtendedSimnet;\n    private readonly contractInterface: any;\n    private readonly contractName: string;\n    private readonly _extends: any;\n    protected constructor(simnet: ExtendedSimnet, contractName: string, sender: string = 'wallet_1', _debug: boolean = false, _extends: any = null) {\n      this._extends = _extends;\n      this.contractName = contractName;\n      this._sender = sender;\n      this.simnet = simnet\n      \n      const contract = Array.from(this.simnet.getContractsInterfaces().keys()).find(c => {\n        return this.contractName === c.split('.')[1];\n      })\n\n      if (!contract) throw Error(`Contract ${contractName} not found`);\n      this.contractInterface = this.simnet.getContractsInterfaces().get(contract);\n    }\n    \n    getSender(): string {\n      return this.simnet.getPrincipal()\n    }\n\n    getPrincipal() {\n      return this.simnet.getDeployedContractPrincipal(this.contractName);\n    }\n\n    private tryGetFnInterface(maybeFnName: string) {\n        return this.contractInterface.functions.find((fn: any) => {\n          return kebabToCamel(fn.name) == maybeFnName;\n        });\n    }\n\n    static create<T extends ClarityContract>(simnet: ExtendedSimnet, contractName: string, sender: string = 'wallet_1', _debug: boolean = false, _extends: T|null = null) {\n      const instance = new this(simnet, contractName, sender, _debug, _extends);\n      return new Proxy(instance, {\n        get: (target: typeof instance, prop: string, receiver) => {\n          const maybeInterface = target.tryGetFnInterface(prop);\n\n          // first, attempt to proxy to the smart contract interface\n          if (maybeInterface) {\n            return function (...args: any[]) {\n              if (args.length != maybeInterface.args.length) throw Error(`Wrong number of arguments, expecting: ${JSON.stringify(maybeInterface.args)}`);\n              if (maybeInterface.access == 'public') {\n                return target.simnet.callPublicFn(contractName, maybeInterface.name, [...args]);\n              } else {\n                return target.simnet.callReadOnlyFn(contractName, maybeInterface.name, [...args]);\n              }\n            };\n          }\n\n          // then, try to proxy to the extended class\n          if (_extends) {\n            const maybeFn = _extends[prop as keyof typeof _extends];\n            if (typeof maybeFn === 'function') {\n              return function (...args: any[]) {\n                return (maybeFn as Function).apply(_extends, args);\n              };\n            } else {\n              return _extends[prop as keyof typeof _extends];\n            }\n          }\n\n          // finally, try to proxy to the base class\n          const maybeFn = target[prop as keyof typeof instance];\n          if (typeof maybeFn === 'function') {\n            return function (...args: any[]) {\n              return (maybeFn as Function).apply(target, args);\n            };\n          } else {\n            return target[prop as keyof typeof instance];\n          }\n        }\n      });\n    }\n\n    connect(sender: string | undefined): this {\n       return ClarityContract.create(this.simnet, this.contractName, this.simnet._parseSender(sender || this.simnet._defaultSender), this.simnet._debug, this._extends) as this;\n    }\n\n    get debug(): this {\n        return ClarityContract.create(this.simnet, this.contractName, this.simnet.sender, true, this._extends) as this;\n    }\n}"],"mappings":"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","names":["maybeFn"]}